#include "../devSettings.h"
#include "../devHardware.h"
#include "devSerialUART.h"
#include <avr/interrupt.h>
//---------------------------------------------------------------------------------------





/* //===================================================================================*
* //                                                                                    *
* // обработчик прерывания по завершению передачи 										*
* //------------------------------------------------------------------------------------*
*///
ISR(USART_UDRE_vect)
{
	AHardware *hw = ptrHardware;
	if (hw)
	{
		hw->uart.isrUDREhandle();
	}
}
//---------------------------------------------------------------------------------------






/* //===================================================================================*
* //                                                                                    *
* // обработчик прерывания по завершению приема данных из порта							*
* //------------------------------------------------------------------------------------*
*///
ISR(USART_RX_vect)
{
	AHardware *hw = ptrHardware;
	if (hw)
	{
		hw->uart.isrRXhandle();
	}
}
//---------------------------------------------------------------------------------------








/* //===================================================================================*
* //                                                                                    *
* // Constructor																		*
* //------------------------------------------------------------------------------------*
*///
ASerialUART :: ASerialUART()
	:
	m_readLock(false),
	m_writeLock(false)
	
{
	
}
//---------------------------------------------------------------------------------------










/* //===================================================================================*
* //                                                                                    *
* // инциализация системы																*
* //------------------------------------------------------------------------------------*
*///
void ASerialUART :: initialization()
{
	DDRD |= (1 << PORTD1);
	PORTD &= ~(1 << PORTD1);
	
	
	/* настройка скорости
	*/
	setBaudRate(9600);
	
	
	/* разрешаем прерывания при риеме и передачи данных
	*/
	UCSR0B = (1<<RXCIE0) | (1<<RXEN0) | (1<<TXEN0);

	disableTxInterrupt();
	

	m_readLock = false;
	m_writeLock = true;
	
	

	
	///отладко запихнем информацию
	/*
	char stest[]=" \r";
	char *s = stest;
	while (*s)
	{
		m_read.push_back(*s);
		s++;
	}
	*/
}
//---------------------------------------------------------------------------------------








/* //===================================================================================*
* //                                                                                    *
* // Установка скорости передачи данных													*
* //------------------------------------------------------------------------------------*
*///
void ASerialUART :: setBaudRate(const DWORD dwBaud)
{
	//unsigned long baud = 9600;
	const WORD baud_ubrr = (F_CPU - 8 * dwBaud) / (16 * dwBaud);
	UBRR0 = baud_ubrr;
}
//---------------------------------------------------------------------------------------






/* //===================================================================================*
* //                                                                                    *
* // проверка, есть данные для чтения или нет											*
* //------------------------------------------------------------------------------------*
*///
bool ASerialUART :: onIsRead() const
{
	return m_read.count() > 0 ? true : false;
}
//---------------------------------------------------------------------------------------








/* //===================================================================================*
* //                                                                                    *
* // чтение данных из порта																*
* // если данных нет, то возвратим 0													*
* //------------------------------------------------------------------------------------*
*///
BYTE ASerialUART :: onRead()
{
	m_readLock = true;
	BYTE data =  m_read.pop_front();
	m_readLock = false;
	return data;
}
//---------------------------------------------------------------------------------------







/* //===================================================================================*
* //                                                                                    *
* // запись данных в поток																*
* // если буфер переполнен, то возвратим false											*
* //------------------------------------------------------------------------------------*
*///
bool ASerialUART :: onWrite(BYTE data)
{
	m_writeLock = true;
	
	// UDRE0 - 1 данные можно записывать в порт
	if ( UCSR0A & (1<<UDRE0) && m_write.count() == 0)
	{
		m_writeLock = false;
		enableTxInterrupt();
		UDR0 = data;
		return true;			
	}

	//иначе запишем в буфер
	bool okWrite =  m_write.push_back(data);
	m_writeLock = false;
	enableTxInterrupt();
	return okWrite;		
}
//---------------------------------------------------------------------------------------







/* //===================================================================================*
* //                                                                                    *
* // Обработчик прерывания, данные успешно отправленны									*
* //------------------------------------------------------------------------------------*
*///
void ASerialUART :: isrUDREhandle()
{
	if (!m_writeLock)
	{
		disableTxInterrupt();
		if (m_write.count())
		{
			//отправим следующую порцию данных
			UDR0 = m_write.pop_front();
			enableTxInterrupt();
		}
	}		
}
//---------------------------------------------------------------------------------------






/* //===================================================================================*
* //                                                                                    *
* // прерывание по завершению приема													*
* //------------------------------------------------------------------------------------*
*///
void ASerialUART :: isrRXhandle()
{
	if (!m_readLock)
	{
		//пришли новые данные, запишем их в кольцевой буфер
		UCSR0B &= ~(1<<RXCIE0);
		m_read.push_back(UDR0);
		UCSR0B |= (1<<RXCIE0);
	}		
}
//---------------------------------------------------------------------------------------






/* //===================================================================================*
* //                                                                                    *
* // включение прерывания на прием данных												*
* //------------------------------------------------------------------------------------*
*///
void ASerialUART :: enableTxInterrupt()
{
	UCSR0B |= (1<<UDRIE0);
}
//---------------------------------------------------------------------------------------




/* //===================================================================================*
* //                                                                                    *
* // отключение прерывания на прием данных												*
* //------------------------------------------------------------------------------------*
*///
void ASerialUART :: disableTxInterrupt()
{
	UCSR0B &= ~(1<<UDRIE0);
}
//---------------------------------------------------------------------------------------


