#include "prtProxyTerminal.h"
//---------------------------------------------------------------------------------------



//---------------------------------------------------------------------------------------







/* //===================================================================================*
* //                                                                                    *
* // Constructor																		*
* //------------------------------------------------------------------------------------*
*///
AProxyTerminal :: AProxyTerminal()
	:
	m_connect(false),
	m_isInput(false),
	m_count(0)
{
	clearBuffer();
}
//---------------------------------------------------------------------------------------







/* //===================================================================================*
* //                                                                                    *
* // проверка, являятся ли данные корректны для терминала								*
* // главное смотрим чтобы был диапазон аски символов, остальное отсекаем               *
* //------------------------------------------------------------------------------------*
*///
bool AProxyTerminal :: isCorrect(const BYTE data) const
{
	#ifdef _TESTCMD
		return true;
	#endif // _TESTCMD


	//return (data >= 0x20) || m_isInput ? true : false;
	
	return (data == KEY_CR) || (((data >= 0x20) || m_isInput) && m_connect) ? true : false;
}
//---------------------------------------------------------------------------------------








/* //===================================================================================*
* //                                                                                    *
* // Обработка и выделение командной строки												*
* //------------------------------------------------------------------------------------*
*///
void AProxyTerminal :: execute(const BYTE data, AStream *stream)
{
	#ifdef _TESTCMD
		stream->write('.');
		char szBuffer[50];
		zeroMemory((BYTE*)szBuffer, 50);
		strFromInt(szBuffer, data);
		stream->print(szBuffer);
		stream->write('.');
		sendEnter(stream);
		return;
	#endif // _TESTCMD
		
	
	
	switch (data)
	{
		case KEY_CR :
		{
			if (m_connect)
			{
				cmdEnter(stream);
			}
			else
			{
				cmdConnect(stream);				
			}
			break;
		}
		
		case KEY_BS:
		case KEY_DEL :
		{
			cmdBackspace(stream);
			break;
		}

		default:
		{
			cmdPushChar(data, stream);
		}
	}
}
//---------------------------------------------------------------------------------------







/* //===================================================================================*
* //                                                                                    *
* // Очистка буфера данных																*
* //------------------------------------------------------------------------------------*
*///
void AProxyTerminal :: clearBuffer()
{
	for (int i=0; i < MAX_TERMINAL_BUFFER; i++)
	{
		m_Buffer[i] = 0;	
	}
	m_count = 0;
	m_isInput = false;
}
//---------------------------------------------------------------------------------------






/* //===================================================================================*
* //                                                                                    *
* // послать символ в терминал перевода картеки											*
* //------------------------------------------------------------------------------------*
*///
const void AProxyTerminal :: sendEnter(AStream *stream)
{
	stream->write('\r');
	stream->write('\n');
}
//---------------------------------------------------------------------------------------





/* //===================================================================================*
* //                                                                                    *
* // переместить курсор выше на количество линий										*
* //------------------------------------------------------------------------------------*
*///
const void AProxyTerminal :: sendCursorUP (const int line, AStream *stream)
{
	stream->write(KEY_ESC);
	stream->write('[');
	stream->write('0'+line);
	stream->write('A');
}
//---------------------------------------------------------------------------------------





/* //===================================================================================*
* //                                                                                    *
* // стереть все данные которые находятся справа от курсора								*
* //------------------------------------------------------------------------------------*
*///
const void AProxyTerminal :: sendClearRight (AStream *stream)
{
	stream->write(KEY_ESC);
	stream->write('[');
	stream->write('K');
}
//---------------------------------------------------------------------------------------




		







/* //===================================================================================*
* //                                                                                    *
* // перевод каретки																	*
* //------------------------------------------------------------------------------------*
*///
void AProxyTerminal :: cmdEnter(AStream *stream)
{
	sendEnter(stream);
	m_isInput = false;

	//разбор командной строки
	char* argv[MAX_TERMINAL_ARGV];
	int argc = getArg(argv);
	
	//выполнение команды с параметрами
	onInterpretation(argc, argv, stream);
	cmdCallCommand(stream);
}
//---------------------------------------------------------------------------------------





/* //===================================================================================*
* //                                                                                    *
* // разбор буферной строки на команды и параметры										*
* //------------------------------------------------------------------------------------*
*///
int AProxyTerminal :: getArg(char * argv[])
{
	for (int i = 0; i < MAX_TERMINAL_ARGV; i++)
	{
		argv[i]=0;
	}
	int argc = 0;
	
	//первое вхождение команда
	bool boArg = true;//текущий символ это начала значения
	int count = strLength(m_Buffer);
	for (int i = 0; i < count; i++)
	{
		if (m_Buffer[i] == ' ')
		{
			m_Buffer[i] = 0;
			boArg = true; //следующий символ будет значением
		}
		else
		if (boArg && argc < MAX_TERMINAL_ARGV)
		{
			//первый символ являтся значением
			argv[argc] = m_Buffer + i;
			argc++;
			boArg = false;
		}
	}
	return argc;
}
//---------------------------------------------------------------------------------------






/* //===================================================================================*
* //                                                                                    *
* // вставка символа																	*
* // последний символ всегда 0 конец строки
* //------------------------------------------------------------------------------------*
*///
void AProxyTerminal :: cmdPushChar(const BYTE data, AStream *stream)
{
	if (data >= 0x20 && m_count < MAX_TERMINAL_BUFFER - 1)
	{
		//вводим обычный символ
		m_Buffer[m_count] = data;
		m_count++;
		m_isInput = true;
		stream->write(data);
	}
}
//---------------------------------------------------------------------------------------






/* //===================================================================================*
* //                                                                                    *
* // удаление символа																	*
* //------------------------------------------------------------------------------------*
*///
void AProxyTerminal :: cmdBackspace(AStream *stream)
{
	if (m_count > 0)
	{
		m_count--;
		m_Buffer[m_count] = 0;
		stream->write(KEY_DEL);
		if (m_count == 0)
		{
			//коннец ввода строки
			m_isInput = false;
		}
	}
}
//---------------------------------------------------------------------------------------





/* //===================================================================================*
* //                                                                                    *
* // подсоеденение к терминалу															*
* //------------------------------------------------------------------------------------*
*///
void AProxyTerminal :: cmdConnect(AStream *stream)
{
	m_connect = true;
	stream->printPgm(TEXT("Connect: "));
	stream->printPgm(TEXT(NAME_TERMINAL));
	cmdCallCommand(stream);
}
//---------------------------------------------------------------------------------------







/* //===================================================================================*
* //                                                                                    *
* // приглашение на новую команду														*
* //------------------------------------------------------------------------------------*
*///
void AProxyTerminal :: cmdCallCommand(AStream *stream)
{
	if (m_connect)
	{
		clearBuffer();
		sendEnter(stream);
		stream->write('>');
		stream->write(' ');
	}		
}
//---------------------------------------------------------------------------------------





/* //===================================================================================*
* //                                                                                    *
* // выход из терминала																	*
* //------------------------------------------------------------------------------------*
*///
void AProxyTerminal :: exit(AStream *stream)
{
	m_connect = false;
	clearBuffer();
	stream->printPgm(TEXT("disconnect"));
	sendEnter(stream);
}
//---------------------------------------------------------------------------------------

