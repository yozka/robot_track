#include "devFIFO.h"
//---------------------------------------------------------------------------------------



//---------------------------------------------------------------------------------------







/* //===================================================================================*
* //                                                                                    *
* // Constructor																		*
* //------------------------------------------------------------------------------------*
*///
AFIFO :: AFIFO()
	:
	m_indexBegin(0),
	m_indexEnd(0),
	m_count(0)
{
	
}
//---------------------------------------------------------------------------------------









/* //===================================================================================*
* //                                                                                    *
* // очистить очередь																	*
* //------------------------------------------------------------------------------------*
*///
void AFIFO :: clear()
{
	m_indexBegin = 0;
	m_indexEnd = 0;
	m_count = 0;
}
//---------------------------------------------------------------------------------------






/* //===================================================================================*
* //                                                                                    *
* // Запихнем данные в конец очереди													*
* //------------------------------------------------------------------------------------*
*///
bool AFIFO :: push_back(const BYTE data)
{
	if (m_count < MAX_CIRCULAR_BUFFER)
	{
		m_buffer[m_indexEnd] = data;
		m_indexEnd++;
		m_count++;
		if (m_indexEnd == MAX_CIRCULAR_BUFFER)
		{
			m_indexEnd = 0;
		}
		return true;
	}		
	return false;
}
//---------------------------------------------------------------------------------------




	
	
	
	
/* //===================================================================================*
* //                                                                                    *
* // Вытащим данные из начала очереди													*
* //------------------------------------------------------------------------------------*
*///
BYTE AFIFO :: pop_front()
{
	if (m_count > 0)
	{
		BYTE data = m_buffer[m_indexBegin];
		m_buffer[m_indexBegin] = 0;
		m_indexBegin++;
		m_count--;
	
		if (m_indexBegin == MAX_CIRCULAR_BUFFER)
		{
			//вышли за пределы буфера
			m_indexBegin = 0;
		}
		return data;
	}
	//ошибка, нет данных для чтения
	return 0;		
}
//---------------------------------------------------------------------------------------





/* //===================================================================================*
* //                                                                                    *
* // Количество элементов в буфере														*
* //------------------------------------------------------------------------------------*
*///
int AFIFO :: count() const
{
	return m_count;
}
//---------------------------------------------------------------------------------------




